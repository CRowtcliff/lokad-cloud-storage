<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <!-- =========================================================== 
       Setup the place where we look for the Windows Azure SDK 
       =========================================================== -->

  <!-- Set installation properties. These properties can be overriden to support non-default installation -->
  <PropertyGroup>
    <ServiceHostingSDKInstallDir Condition=" '$(ServiceHostingSDKInstallDir)' == '' ">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\ServiceHosting\v1.0@InstallPath)</ServiceHostingSDKInstallDir>
    <ServiceHostingSDKSupport    Condition=" '$(ServiceHostingSDKSupport)' == '' ">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\ServiceHosting\v1.0@ToolsVersionSupportLevel)</ServiceHostingSDKSupport> 
    <!-- Ensure ServiceHostingSDKInstallDir has a trailing slash, so it can be concatenated -->
    <ServiceHostingSDKInstallDir Condition=" '$(ServiceHostingSDKInstallDir)' != '' and !HasTrailingSlash('$(ServiceHostingSDKInstallDir)')">$(ServiceHostingSDKInstallDir)\</ServiceHostingSDKInstallDir>

    <ServiceHostingSDKBinDir     Condition=" '$(ServiceHostingSDKBinDir)' == '' ">$(ServiceHostingSDKInstallDir)bin\</ServiceHostingSDKBinDir>

    <ServiceHostingSDKTaskPath   Condition=" '$(ServiceHostingSDKTaskPath)' == '' ">$(ServiceHostingSDKBinDir)Microsoft.ServiceHosting.Tools.MSBuildTasks.dll</ServiceHostingSDKTaskPath>

  </PropertyGroup>

  <!-- IntelliTrace related properties that should be overriden externally to enable IntelliTrace. -->
  <PropertyGroup>
    <EnableIntelliTrace Condition="'$(EnableIntelliTrace)' == ''">false</EnableIntelliTrace>
    <IntelliTraceConnectionString Condition="'$(IntelliTraceConnectionString)' == ''">UseDevelopmentStorage=true</IntelliTraceConnectionString>
  </PropertyGroup>
  

  <!-- =========================================================== 
       Bring in the CSPack MSBuild task 
       =========================================================== -->
  <UsingTask TaskName="CSPack"                AssemblyFile="$(ServiceHostingSDKTaskPath)" Condition=" Exists('$(ServiceHostingSDKTaskPath)') " />
  <UsingTask TaskName="ValidateServiceFiles"  AssemblyFile="$(ServiceHostingSDKTaskPath)" Condition=" Exists('$(ServiceHostingSDKTaskPath)') " />

  <!-- =========================================================== 
       Bring in our tasks
       =========================================================== -->
  <PropertyGroup>
    <CloudExtensionsDir       Condition=" '$(CloudExtensionsDir)' == '' ">$(MSBuildExtensionsPath)\Microsoft\Cloud Service\1.0\Visual Studio 10.0\</CloudExtensionsDir>

    <CloudExtensionsTaskPath  Condition=" '$(CloudExtensionsTaskPath)' == '' ">$(CloudExtensionsDir)Microsoft.CloudService.MSBuildTasks.dll</CloudExtensionsTaskPath>
  </PropertyGroup>

  <UsingTask TaskName="ItemGroupsOrderedMerge"              AssemblyFile="$(CloudExtensionsTaskPath)" />
  <UsingTask TaskName="IsolatedCSPack"                      AssemblyFile="$(CloudExtensionsTaskPath)" />
  <UsingTask TaskName="FindTargetPath"                      AssemblyFile="$(CloudExtensionsTaskPath)" />
  <UsingTask TaskName="DeleteCurrentDeployment"             AssemblyFile="$(CloudExtensionsTaskPath)" />
  <UsingTask TaskName="WATMessage"                          AssemblyFile="$(CloudExtensionsTaskPath)" />
  <UsingTask TaskName="AddIntelliTraceToServiceDefinition"    AssemblyFile="$(CloudExtensionsTaskPath)" />
  <UsingTask TaskName="AddIntelliTraceToServiceConfiguration" AssemblyFile="$(CloudExtensionsTaskPath)" />


  <!-- ===========================================================  
       Import the Common targets file and override the standard 
       tasks that VS expects to perform a build 
       =========================================================== -->

  <!-- Import the Common targets file -->
  <Import Project="$(MSBuildBinPath)\Microsoft.Common.targets" />

  <!-- =========================================================== 
       Property Declarations
       =========================================================== -->

  <PropertyGroup>

    <!-- The level of ToolsVersionSupportLevel this msi will support-->
    <ServiceHostingVSSupport>6</ServiceHostingVSSupport>
    <!-- Example, bin\Debug\Compute.csx\  -->
    <ServiceOutputDirectory Condition=" '$(ServiceOutputDirectory)' == '' ">$(OutDir)$(ProjectName).csx\</ServiceOutputDirectory>

    <!-- The local path where Windows Azure compiler outputs the roles -->
    <ServiceHosting_HardcodedDirectory Condition =" '$(ServiceHosting_HardcodedDirectory)' == '' ">roles\</ServiceHosting_HardcodedDirectory>

    <!-- The namespace of the service definition and service configuration xml files -->
    <ServiceDefinitionNamespace>http://schemas.microsoft.com/ServiceHosting/2008/10/ServiceDefinition</ServiceDefinitionNamespace>
    <ServiceConfigurationNamespace>http://schemas.microsoft.com/ServiceHosting/2008/10/ServiceConfiguration</ServiceConfigurationNamespace>

  </PropertyGroup>
  
  <!-- =========================================================== 
       Override the CoreBuildDependsOn property from Microsoft.Common.targets
       to the targets that are needed for the CloudExtensions target
       =========================================================== -->

  <PropertyGroup>
    <CoreBuildDependsOn>
      BuildOnlySettings;
      PrepareForBuild;
      PreBuildEvent;
      ResolveReferences;
      PackageComputeService;
      GetTargetPath;
      IncrementalClean;
      PostBuildEvent
    </CoreBuildDependsOn>
  </PropertyGroup>
  
  <!-- =============== PackageComputeService ======================================== 
       Packages the compute service project
       ============================================================================== -->
  <PropertyGroup>
    <PackageComputeServiceDependsOn>
      BeforePackageComputeService;
      CorePackageComputeService;
      AfterPackageComputeService;
    </PackageComputeServiceDependsOn>
  </PropertyGroup>
  <Target
      Name="PackageComputeService"
      DependsOnTargets="$(PackageComputeServiceDependsOn)" />

  <!-- Redefine this target in your project in order to run tasks just before Build -->
  <Target Name="BeforePackageComputeService" />

  <!-- Redefine this target in your project in order to run tasks just before Build -->
  <Target Name="AfterPackageComputeService" />

  <!-- =============== CorePackageComputeService ==================================== 
       This is the core packaging target. It uses CSPack task to package the compute
       project. 
       ============================================================================== -->
  <PropertyGroup>
    <CorePackageComputeServiceDependsOn>
      VerifySDKInstallation;
      FindServiceDefinition;
      FindServiceConfiguration;
      ResetTargetNames;
      ValidateComputeProject;
      DeleteCurrentDeployment;
      ResolveRoleReferences;
      IntelliTrace;
    </CorePackageComputeServiceDependsOn>
  </PropertyGroup>
  <Target
      Name="CorePackageComputeService"
      DependsOnTargets="$(CorePackageComputeServiceDependsOn)">

    <Message Text="Start - PackageComputeService" />
    <Message Text="ServiceHostingSDKInstallDir is $(ServiceHostingSDKInstallDir)" />
    <Message Text="ServiceDefinitionWithIntelliTrace is @(ServiceDefinitionWithIntelliTrace)" />

    <ItemGroup>
      <Roles Include="@(RoleReferences->'%(OutputDir)')" >
        <RoleName>%(RoleName)</RoleName>
        <EntryPoint>%(EntryPoint)</EntryPoint>
        <SourceDir>%(SourceDir)</SourceDir>
      </Roles>
      <RoleProperties Include="@(RoleReferences->'%(RoleName)')">
        <EntryPoint>%(EntryPoint)</EntryPoint>
        <TargetFrameworkVersion>%(RoleTargetFramework)</TargetFrameworkVersion>
        <RolePlugins Condition="'$(EnableIntelliTrace)'=='true' and %(RoleTargetFramework)=='v4.0'">$(IntelliTraceTargetDir)</RolePlugins>
      </RoleProperties>
    </ItemGroup>

    <PropertyGroup>
      <ServiceDefinitionFile Condition="'$(EnableIntelliTrace)'=='true'">@(ServiceDefinitionWithIntelliTrace)</ServiceDefinitionFile>
      <ServiceDefinitionFile Condition="'$(EnableIntelliTrace)'!='true'">@(ServiceDefinition)</ServiceDefinitionFile>
    </PropertyGroup>

    <Message Text="ModelFile            is $(ServiceDefinitionFile)" />
    <Message Text="OutputDirectory      is $(ServiceOutputDirectory)" />
    <Message Text="PackRoles            is @(Roles), Name=%(RoleName), EntryPoint=%(EntryPoint), SourceDir=%(SourceDir)" />
    <Message Text="RoleProperties       is @(RoleProperties), EntryPoint=%(EntryPoint), TargetFrameworkVersion=%(TargetFrameworkVersion)" />

    <Message Text="Calling ServicePack" />

    <CSPack
      ServiceDefinitionFile="$(ServiceDefinitionFile)"
      Output="$(ServiceOutputDirectory)"
      PackRoles="@(Roles)"
      RoleProperties="@(RoleProperties)"
      CopyOnly="true"
     >
      <Output TaskParameter="OutputFiles" ItemName="FileWrites" />
    </CSPack>

    <!-- Add generated policy files and others to the FileWrites list -->
    <ItemGroup>
      <FileWrites Include=" $(ServiceOutputDirectory)**\__entrypoint.txt " />
    </ItemGroup>

    <!-- Copy service configuration to output directory -->
    <Message Text="Copying the service configuration." />
    <Copy
      SourceFiles="@(ServiceConfiguration)"
      DestinationFolder="$(OutDir)"
     >
      <Output TaskParameter="CopiedFiles" ItemName="FileWrites" />
    </Copy>

    <AddIntelliTraceToServiceConfiguration
      ServiceConfigurationFile="$(OutDir)@(ServiceConfiguration)"
      IntelliTraceConnectionString="$(IntelliTraceConnectionString)"
      Condition="$(EnableIntelliTrace)=='true'" />

    <Message Text="End - PackageComputeService" />

  </Target>


  <!-- =============== VerifySDKInstallation ======================================== 
       Verify that the Computing SDK is installed and it is compatible with this version of tools
       ============================================================================== -->
  <Target 
      Name="VerifySDKInstallation">

    <WATMessage Condition=" !Exists('$(ServiceHostingSDKInstallDir)') or 
                            !Exists('$(ServiceHostingSDKBinDir)') or 
                            !Exists('$(ServiceHostingSDKTaskPath)') "
                Type="Error"
                Code="WAT080" />

    <WATMessage Condition="'$(ServiceHostingSDKSupport)' != '$(ServiceHostingVSSupport)'" Type="Error" Code="WAT050" HelpKeyword="SDKVersionNotSupported" />
        
  </Target>

  <!-- =============== FindServiceDefinition  ============================================ 
       Finds the service definition in the project and raises an error if it is not found. 
       ============================================================================== -->
  <Target 
      Name="FindServiceDefinition">

    <!--Find the Compute Application Model File -->
    <Message Text="ServiceDefinition in @(ServiceDefinition)" Importance="normal"/>

    <WATMessage Condition=" '@(ServiceDefinition)' == '' "
           Type="Error"
           Code="WAT010"
           HelpKeyword="MissingModelFile"/>

    <!-- Only one active service definition can be active, check for that and throw an error -->
    <WATMessage Condition=" '@(ServiceDefinition)' == '' or '@(ServiceDefinition->'%(dummy)')' != '' "
           Type="Error"
           Code="WAT020"
           HelpKeyword="OneActiveModelFile" />
    
  </Target>

  <!-- =============== FindServiceConfiguration  ============================================ 
       Finds the Service Configuration file in the project and raises an error if it is not found. 
       ============================================================================== -->
  <Target 
      Name="FindServiceConfiguration">

    <Message Text="ServiceConfigurationFile is @(ServiceConfiguration)" />

    <!-- Compute project must contain at least one service configuration file -->
    <WATMessage Condition=" '@(ServiceConfiguration)' == '' "
                Type="Error"
                Code="WAT030"
                HelpKeyword="MissingServiceConfiguration" />

    <!-- Only one service configuration per compute project, check for that and throw an error -->
    <WATMessage Condition=" '@(ServiceConfiguration)' == '' or '@(ServiceConfiguration->'%(dummy)')' != '' "
           Type="Error"
           Code="WAT040"
           HelpKeyword="OneServiceConfigurationFile" />

  </Target>


  <!-- =============== ResetTargetNames  ==================================== 
       Resets the $(TargetName) and $(TargetExt) to be compute specific.

       Properties:
           TargetName - the name of the compute app model file 
           TargetExt  - the extension of the compute app model file 
       ========================================================================== -->
  <Target 
      Name="ResetTargetNames">

    <PropertyGroup>
      <TargetDir>$(ServiceOutputDirectory)</TargetDir>
      <TargetName>@(ServiceDefinition->'%(filename)')</TargetName>
      <TargetExt>.rd</TargetExt>
      <TargetFileName>$(TargetName)$(TargetExt)</TargetFileName>
      <TargetPath>$(TargetDir)$(TargetFileName)</TargetPath>
    </PropertyGroup>

    <Message Text="Reset the targetDir      to $(TargetDir)" />
    <Message Text="Reset the TargetName     to $(TargetName)" />
    <Message Text="Reset the TargetExt      to $(TargetExt)" />
    <Message Text="Reset the TargetFileName to $(TargetFileName)" />
    <Message Text="Reset the TargetPath     to $(TargetPath)" />

  </Target>

  <!-- =============== DeleteCurrentDeployment ================================== 
       Delete the current running deployment that is attached with the project.

       ========================================================================== -->

  <Target
      Name="DeleteCurrentDeployment">

    <!-- This task runs only under Visual Studio -->
    <DeleteCurrentDeployment Condition="'$(BuildingInsideVisualStudio)' == 'true' " />

  </Target>

  <!-- =============== ResolveRoleReferences ======================== 
       Finds the role projects defined in the project file.      

       [OUT]
       
       RoleReferences: (item) list of all project references for
            web and worker. Each item contains these properties:
              - @         : Path to the project file.
              - RoleType  : The type of the role: Web, or Worker.
              - RoleName  : The name of the role.
              - ProjectName: The project name of the role.
              - Platform  : CPU Platform of the role project.
              - OutputDir : The path where we can find the outputs of the role.
              - SourceDir : (web specific) The source location of the web role.
              - EntryPoint: The entry point assembly file name for web/worker role.
              
      ========================================================================== -->
  <PropertyGroup>
    <ResolveRoleReferencesDependsOn>
      VerifyRoleReferences;
      ResolveWebRoleReferences;
      ResolveWorkerRoleReferences;
    </ResolveRoleReferencesDependsOn>
  </PropertyGroup>
  <Target 
      Name="ResolveRoleReferences" 
      DependsOnTargets="$(ResolveRoleReferencesDependsOn)">

    <!-- Combine WebRoleReferences and WorkerRoleReferences -->
    <ItemGroup>
      <RoleReferences Include="@(WebRoleReferences); @(WorkerRoleReferences)" />
    </ItemGroup>

    <Message Text="Role = @(RoleReferences), role=%(RoleType), projname=%(ProjectName), output=%(OutputDir)" />

  </Target>


  <!-- =============== VerifyRoleReferences ======================== 
       Verifies that the key output exists for all role references 

      ========================================================================== -->
  <Target
      Name="VerifyRoleReferences">

    <WATMessage
      Condition=" !Exists('%(_ResolvedProjectReferencePaths.Identity)')"
      Type="Error"
      Arguments="%(_ResolvedProjectReferencePaths.Identity)"
      Code="WAT070"
      />
  </Target>

  <!-- =============== ResolveWebRoleReferences ======================== 
       Resolves the web role references

       [OUT]
       
       WebRoleReferences: (item) list of all project references for web
              - @         : Path to the project file.
              - RoleType  : The type of the role: Web
              - RoleName  : The name of the role.
              - ProjectName: The project name of the role.
              - Platform  : CPU Platform of the role project.
              - OutputDir : The path where we can find the outputs of the role.
              - SourceDir : The source location of the web role
              - EntryPoint: The entry point assembly file name for web.
              
      ========================================================================== -->
  <Target 
      Name="ResolveWebRoleReferences">
    
    <!-- Get all the roles from the project references section -->
    <ItemGroup>
      <WebRoleProjects Include="@(ProjectReferenceWithConfiguration->'%(Identity)')" Condition=" '%(RoleType)' == 'Web' " >
        <ProjectName>%(Name)</ProjectName>
        <Configuration>%(ProjectReferenceWithConfiguration.Configuration)</Configuration>
        <Platform>%(ProjectReferenceWithConfiguration.Platform)</Platform>
      </WebRoleProjects>
    </ItemGroup>

    <MSBuild
      Condition=" '@(WebRoleProjects)' != '' "
      Projects="$(MSBuildProjectFullPath)"
      Targets="ResolveSingleWebRoleReference"
      Properties="WebRoleProject=%(Identity);WebRoleProjectName=%(Name);WebRoleConfiguration=%(Configuration);WebRolePlatform=%(Platform)"
      ContinueOnError="false"
      >
      <Output TaskParameter="TargetOutputs" ItemName="WebRoleReferences" />
    </MSBuild>

    <Message Text="WebRoleReferences=@(WebRoleReferences) %(RoleType), %(RoleName), %(ProjectName), %(Configuration), %(Platform), %(SourceDir), %(OutputDir), %(EntryPoint)" />

    <!-- Register intermediate published web role for Clean -->
    <ItemGroup Condition=" '@(WebRoleReferences)' != '' ">
      <FileWrites Include="%(WebRoleReferences.OutputDir)**\*.*" />
    </ItemGroup>    
    
  </Target>

  <!-- =============== ResolveSingleWebRoleReference ======================== 
       Resolves a single web role reference. This target publishes the web
       role into an intermediate folder making it ready for CSPack.
       
       [IN]
       
       WebRoleProject: (property) the propject of web role
       WebRoleProjectName: (property) the project name of the web role
       WebRoleConfiguration: (property) the configuration of the web role
       WebRolePlatform: (property) the platform of the web role

       [OUT]
       
       WebRoleReference: (item) Contains information about the web role
              - @         : Path to the project file, same as $(WebRoleProject)
              - RoleType  : The type of the role: Web
              - RoleName  : The name of the role.
              - ProjectName: The project name of the role, same as $(WebRoleProjectName)
              - Configuration: The configuration used on the role project.
              - Platform  : CPU Platform of the role project.
              - OutputDir : The path where we can find the outputs of the role.
              - EntryPoint: The entry point assembly file name for the role.
              - SourceDir : The source location of the web role
              
      ========================================================================== -->
  <Target
      Name="ResolveSingleWebRoleReference"
      Condition=" '$(WebRoleProject)' != '' and '$(WebRoleProjectName)' != '' "
      Outputs="@(WebRoleReference)">

    <Message Text="WebRoleProject=$(WebRoleProject)" />
    <Message Text="WebRoleProjectName=$(WebRoleProjectName)" />
    <Message Text="WebRoleConfiguration=$(WebRoleConfiguration)" />
    <Message Text="WebRolePlatform=$(WebRolePlatform)" />

    <PropertyGroup>
      <!-- If the role configuration wasn't passed, use the current cloud service project configuration -->
      <WebRoleConfiguration Condition="'$(WebRoleConfiguration)' == ''">$(Configuration)</WebRoleConfiguration>
      <!-- If the role platform wasn't passed, use the current cloud service project platform -->
      <WebRolePlatform Condition="'$(WebRolePlatform)' == ''">$(Platform)</WebRolePlatform>
    </PropertyGroup>

    <ItemGroup>
      <WebRoleReference Include="$(WebRoleProject)" >
        <RoleType>Web</RoleType>
        <RoleName>$(WebRoleProjectName)</RoleName>
        <ProjectName>$(WebRoleProjectName)</ProjectName>
        <Configuration>$(WebRoleConfiguration)</Configuration>
        <Platform>$(WebRolePlatform)</Platform>
      </WebRoleReference>
    </ItemGroup>

    <Message Text="WebRoleReference=@(WebRoleReference) %(RoleType), %(RoleName), %(ProjectName), %(Configuration), %(Platform)" />

    <!-- Setup the intermediate path where we want to publish the web role -->
    <ItemGroup>
      <IntermediateWebOutputPathItem Include="$(IntermediateOutputPath)%(WebRoleReference.ProjectName)\" />
    </ItemGroup>
    <PropertyGroup>
      <IntermediateWebOutputPath>@(IntermediateWebOutputPathItem->'%(Fullpath)')</IntermediateWebOutputPath>
    </PropertyGroup>

    <!-- ===============================
         Get the target path for the role 
         =============================== -->
    <MSBuild
      Projects="@(WebRoleReference)"
      Targets="GetTargetPath"
      Properties="Configuration=%(Configuration); Platform=%(Platform)"
      ContinueOnError="false"
      >
      <Output TaskParameter="TargetOutputs" ItemName="WebTargetPathItem" />
    </MSBuild>

    <PropertyGroup>
      <!-- Stores the assembly file name (no path) of the web role -->
      <WebEntryPoint Condition="'@(WebTargetPathItem)'!=''">%(Filename)%(Extension)</WebEntryPoint>
      <!-- The full target dir of the web role binary folder -->
      <WebTargetDir Condition="'@(WebTargetPathItem)'!=''">%(RootDir)%(Directory)</WebTargetDir>
      <!-- The fullpath to the source directory. This is derived from where the project is located -->
      <WebSourceDir Condition="'@(WebRoleReference)'!=''">%(RootDir)%(Directory)</WebSourceDir>
      <!-- To exclude or not to exclude the pdb files. By default they are not excluded. Set this to true to exclude them -->
      <WebExcludeGeneratedDebugSymbol Condition="'$(ExcludeWebRoleGeneratedDebugSymbol)' == ''">False</WebExcludeGeneratedDebugSymbol>
    </PropertyGroup>

    <Message Text="WebEntryPoint = $(WebEntryPoint)" />
    <Message Text="WebTargetDir = $(WebTargetDir)" />
    <Message Text="WebSourceDir = $(WebSourceDir)" />
    <Message Text="WebExcludeGeneratedDebugSymbol = $(WebExcludeGeneratedDebugSymbol)" />

    <!-- ===============================
         Collect the TargetFrameworkVersion 
         property from web project 
         =============================== -->
    <MSBuild
      Projects="@(WebRoleReference)"
      Targets="GetTargetFrameworkVersion"
      Properties="Configuration=%(Configuration); Platform=%(Platform)"
      ContinueOnError="false"
      >
      <Output TaskParameter="TargetOutputs" PropertyName="RoleTargetFramework" />
    </MSBuild>
    <Message Text="WebTargetFramework = $(RoleTargetFramework)" />
    <!-- ===============================
         Collect the web files from web project 
         =============================== -->
    <MSBuild
      Projects="@(WebRoleReference)"
      Targets="PipelineTransformPhase"
      Properties="Configuration=%(Configuration); Platform=%(Platform); OutDir=$(WebTargetDir); ExcludeGeneratedDebugSymbol=$(WebExcludeGeneratedDebugSymbol); PipelineDependsOnBuild=False"
      ContinueOnError="false">
      <Output TaskParameter="TargetOutputs" ItemName="TransformedWebFiles" />
    </MSBuild>

    <Message Text="TransformedWebFiles = @(TransformedWebFiles), DestinationRelativePath=%(DestinationRelativePath), Exclude=%(Exclude), FromTarget=%(FromTarget), Category=%(Category), ProjectFileType=%(ProjectFileType)" />

    <ItemGroup>
      <WebFiles Condition="'@(TransformedWebFiles)' != '' and '%(Exclude)' == 'False'"
                      Include="$([System.IO.Path]::Combine(`$(WebSourceDir)`, '%(Identity)'))">
        <TargetPath>%(DestinationRelativePath)</TargetPath>
      </WebFiles>
    </ItemGroup>

    <!-- ===============================
         Get all the CopyToOutput items from the role 
         =============================== -->
    <MSBuild
      Projects="@(WebRoleReference)"
      Targets="GetCopyToOutputDirectoryItems"
      Properties="Configuration=%(Configuration); Platform=%(Platform); OutDir=$(WebTargetDir)"
      ContinueOnError="false"
      >
      <Output TaskParameter="TargetOutputs" ItemName="CopyToOutputItems" />
    </MSBuild>

    <Message Text="CopyToOutputItems=%(CopyToOutputItems.Identity) -> %(TargetPath)" />

    <ItemGroup>
      <WebFiles Include="$(WebTargetDir)%(TargetPath)" Condition=" '@(CopyToOutputItems)' != '' ">
        <TargetPath>bin\%(TargetPath)</TargetPath>
      </WebFiles>
    </ItemGroup>

    <!-- ===============================
         At this point the WebFiles list is ready, just publish it
         =============================== -->

    <Message Text="WebFiles=%(WebFiles.Identity) -> %(TargetPath)" />

    <!-- Make sure the intermediate worker ouput folder is created -->
    <MakeDir Directories="$(IntermediateWebOutputPath)" />

    <!-- Remove the files located under the intermediate output folder that are orphaned.
         In other words, remove those files that are not part of the worker project anymore.
         For example, the user renamed a file from test1.dll to test2.dll.
    -->
    <ItemGroup>
      <OrphanedWebFiles Include="$(IntermediateWebOutputPath)**\*.*" Exclude="@(WebFiles->'$(IntermediateWebOutputPath)%(TargetPath)')" />
    </ItemGroup>
    <Delete Files="@(OrphanedWebFiles)" ContinueOnError="true" />

    <!-- Publish the worker to the intermediate folder -->
    <Copy
      Condition=" '@(WebFiles)' != '' "
      SourceFiles="@(WebFiles)"
      DestinationFiles="@(WebFiles->'$(IntermediateWebOutputPath)%(TargetPath)')"
      SkipUnchangedFiles="true" />

    <!-- Add OutputDir, EntryPoint and SourceDir metadata to the WebRoleReference item group -->
    <ItemGroup>
      <WebRoleReference Condition="'@(WebRoleReference)' != ''">
        <OutputDir>$(IntermediateWebOutputPath)</OutputDir>
        <EntryPoint>$(WebEntryPoint)</EntryPoint>
        <SourceDir>$(WebSourceDir)</SourceDir>
        <RoleTargetFramework>$(RoleTargetFramework)</RoleTargetFramework>
      </WebRoleReference>
    </ItemGroup>

    <Message Text="WebRoleReference=@(WebRoleReference) %(RoleType), %(RoleName), %(ProjectName), %(Configuration), %(Platform), %(SourceDir), %(OutputDir), %(EntryPoint)" />

  </Target>

  <!-- =============== ResolveWorkerRoleReferences ======================== 
       Resolves the worker role references

       [OUT]
       WorkerRoleReferences: (item) list of all project references for worker
              - @         : Path to the project file.
              - RoleType  : The type of the role: Worker
              - RoleName  : The name of the role.
              - ProjectName: The project name of the role.
              - Platform  : CPU Platform of the role project.
              - OutputDir : The path where we can find the outputs of the role.
              - SourceDir : not used
              
      ========================================================================== -->
  <Target 
      Name="ResolveWorkerRoleReferences">

    <!-- Get all the roles from the project references section -->
    <ItemGroup>
      <WorkerRoleProjects Include="@(ProjectReferenceWithConfiguration->'%(Identity)')" Condition=" '%(RoleType)' == 'Worker' " >
        <ProjectName>%(Name)</ProjectName>
        <Configuration>%(ProjectReferenceWithConfiguration.Configuration)</Configuration>
        <Platform>%(ProjectReferenceWithConfiguration.Platform)</Platform>
      </WorkerRoleProjects>
    </ItemGroup>

    <MSBuild
      Condition=" '@(WorkerRoleProjects)' != '' "
      Projects="$(MSBuildProjectFullPath)"
      Targets="ResolveSingleWorkerRoleReference"
      Properties="WorkerRoleProject=%(Identity);WorkerRoleProjectName=%(Name);WorkerRoleConfiguration=%(Configuration);WorkerRolePlatform=%(Platform)"
      ContinueOnError="false"
      >
      <Output TaskParameter="TargetOutputs" ItemName="WorkerRoleReferences" />
    </MSBuild>

    <Message Text="WorkerRoleReferences=@(WorkerRoleReferences) %(RoleType), %(RoleName), %(ProjectName), %(Configuration), %(Platform), %(OutputDir), %(EntryPoint)" />

    <!-- Register intermediate published worker role for Clean -->
    <ItemGroup Condition=" '@(WorkerRoleReferences)' != '' ">
      <FileWrites Include="%(WorkerRoleReferences.OutputDir)**\*.*" />
    </ItemGroup>

  </Target>

  <!-- =============== ResolveSingleWorkerRoleReference ======================== 
       Resolves a single worker role reference. This target publishes the worker
       role into an intermediate folder making it ready for CSPack.
       
       [IN]
       
       WorkerRoleProject: (property) the propject of worker role
       WorkerRoleProjectName: (property) the project name of the worker role
       WorkerRoleConfiguration: (property) the configuration of the worker role
       WorkerRolePlatform: (property) the platform of the worker role

       [OUT]
       
       WorkerRoleReference: (item) Contains information about the worker role
              - @         : Path to the project file, same as $(WorkerRoleProject)
              - RoleType  : The type of the role: Worker
              - RoleName  : The name of the role.
              - ProjectName: The project name of the role, same as $(WorkerRoleProjectName)
              - Configuration: The configuration used on the role project.
              - Platform  : CPU Platform of the role project.
              - OutputDir : The path where we can find the outputs of the role.
              - EntryPoint: The entry point assembly file name for the role.
              - SourceDir : not used
              
      ========================================================================== -->
  <Target 
      Name="ResolveSingleWorkerRoleReference"
      Condition=" '$(WorkerRoleProject)' != '' and '$(WorkerRoleProjectName)' != '' "
      Outputs="@(WorkerRoleReference)">

    <Message Text="WorkerRoleProject=$(WorkerRoleProject)" />
    <Message Text="WorkerRoleProjectName=$(WorkerRoleProjectName)" />
    <Message Text="WorkerRoleConfiguration=$(WorkerRoleConfiguration)" />
    <Message Text="WorkerRolePlatform=$(WorkerRolePlatform)" />

    <PropertyGroup>
      <!-- If the role configuration wasn't passed, use the current cloud service project configuration -->
      <WorkerRoleConfiguration Condition="'$(WorkerRoleConfiguration)' == ''">$(Configuration)</WorkerRoleConfiguration>
      <!-- If the role platform wasn't passed, use the current cloud service project platform -->
      <WorkerRolePlatform Condition="'$(WorkerRolePlatform)' == ''">$(Platform)</WorkerRolePlatform>
    </PropertyGroup>

    <ItemGroup>
      <WorkerRoleReference Include="$(WorkerRoleProject)">
        <RoleType>Worker</RoleType>
        <RoleName>$(WorkerRoleProjectName)</RoleName>
        <ProjectName>$(WorkerRoleProjectName)</ProjectName>
        <Configuration>$(WorkerRoleConfiguration)</Configuration>
        <Platform>$(WorkerRolePlatform)</Platform>
        <!-- worker doesn't use SourceDir, set it to empty as default -->
        <SourceDir></SourceDir>
      </WorkerRoleReference>
    </ItemGroup>

    <!-- Setup the intermediate path where we want to publish the worker role -->
    <ItemGroup>
      <IntermediateWorkerOutputPathItem Include="$(IntermediateOutputPath)%(WorkerRoleReference.ProjectName)\" />
    </ItemGroup>
    <PropertyGroup>
      <IntermediateWorkerOutputPath>@(IntermediateWorkerOutputPathItem->'%(Fullpath)')</IntermediateWorkerOutputPath>
    </PropertyGroup>

    <!-- ===============================
         Get the target path for the role 
         =============================== -->
    <MSBuild
      Projects="@(WorkerRoleReference)"
      Targets="GetTargetPath"
      Properties="Configuration=%(Configuration); Platform=%(Platform)"
      ContinueOnError="false"
      >
      <Output TaskParameter="TargetOutputs" ItemName="WorkerTargetPathItem" />
    </MSBuild>

    <PropertyGroup>
      <!-- Stores the worker target directory -->
      <WorkerTargetDir Condition="'@(WorkerTargetPathItem)'!=''">%(RootDir)%(Directory)</WorkerTargetDir>
      <!-- Stores the assembly file name (no path) of the worker role -->
      <WorkerEntryPoint Condition="'@(WorkerTargetPathItem)'!=''">%(Filename)%(Extension)</WorkerEntryPoint>
    </PropertyGroup>

    <Message Text="WorkerTargetDir = $(WorkerTargetDir)" />
    <Message Text="WorkerEntryPoint = $(WorkerEntryPoint)" />

    <!--  =============================== 
          Get all the output groups for the role 
           =============================== -->
    <MSBuild
      Projects="@(WorkerRoleReference)"
      Targets="
        BuiltProjectOutputGroup;
        DebugSymbolsProjectOutputGroup;
        DocumentationProjectOutputGroup;
        SatelliteDllsProjectOutputGroup;
        SGenFilesOutputGroup"
      Properties="AddAppConfigToBuildOutputs=true; Configuration=%(Configuration); Platform=%(Platform)"
      ContinueOnError="false"
      >
      <Output TaskParameter="TargetOutputs" ItemName="OutputGroups" />
    </MSBuild>

    <Message Text="Output=%(OutputGroups.Identity) -> %(TargetPath)" />

    <ItemGroup>
      <WorkerFiles Include="@(OutputGroups)" Condition=" '@(OutputGroups)' != '' " >
        <TargetPath>%(TargetPath)</TargetPath>
      </WorkerFiles>
    </ItemGroup>

    <!-- ===============================
         Get all the dependency output groups for the role 
         =============================== -->
    <MSBuild
      Projects="@(WorkerRoleReference)"
      Targets="
        BuiltProjectOutputGroupDependencies;
        DebugSymbolsProjectOutputGroupDependencies;
        DocumentationProjectOutputGroupDependencies;
        SGenFilesOutputGroupDependencies"
      Properties="Configuration=%(Configuration); Platform=%(Platform)"
      ContinueOnError="false"
      >
      <Output TaskParameter="TargetOutputs" ItemName="OutputGroupsDependencies" />
    </MSBuild>

    <Message Text="OutputDependencies=%(OutputGroupsDependencies.Identity)" />

    <!-- Figure out the dependencies that need to be copied by checking if the dependency exists
         in the worker target directory. -->
    <ItemGroup>
      <CopyLocalDependencies Include="@(OutputGroupsDependencies)" Condition="Exists('$(WorkerTargetDir)%(Filename)%(Extension)')" />
    </ItemGroup>
    <Message Text="CopyLocalDependencies=%(CopyLocalDependencies.Identity)" />
    <ItemGroup>
      <WorkerFiles Include="@(CopyLocalDependencies)" Condition=" '@(CopyLocalDependencies)' != '' " >
        <TargetPath>%(Filename)%(Extension)</TargetPath>
      </WorkerFiles>
    </ItemGroup>

    <!--  ===============================
          Get all Satellite dependecies 
          =============================== -->
    <MSBuild
      Projects="@(WorkerRoleReference)"
      Targets="
        SatelliteDllsProjectOutputGroupDependencies"
      Properties="Configuration=%(Configuration); Platform=%(Platform)"
      ContinueOnError="false"
      >
      <Output TaskParameter="TargetOutputs" ItemName="SatelliteOutputGroupsDependencies" />
    </MSBuild>

    <FindTargetPath
      Files="@(SatelliteOutputGroupsDependencies)"
      FindUnderTargetDir="$(WorkerTargetDir)"
      >
      <Output TaskParameter="ItemWithTargetPath" ItemName="SatelliteOutputGroupsDependenciesWithTargetPath" />
    </FindTargetPath>

    <Message Text="SatelliteOutputGroupsDependenciesWithTargetPath=@(SatelliteOutputGroupsDependenciesWithTargetPath), %(TargetPath)" />

    <ItemGroup>
      <WorkerFiles Include="@(SatelliteOutputGroupsDependenciesWithTargetPath)" Condition=" '@(SatelliteOutputGroupsDependenciesWithTargetPath)' != '' ">
        <TargetPath>%(TargetPath)</TargetPath>
      </WorkerFiles>
    </ItemGroup>

    <!-- ===============================
         Get TargetFrameworkVersion for the role project
         =============================== -->
    <MSBuild
      Projects="@(WorkerRoleReference)"
      Targets="GetTargetFrameworkVersion"
      Properties="Configuration=%(Configuration); Platform=%(Platform)"
      ContinueOnError="false"
      >
      <Output TaskParameter="TargetOutputs" PropertyName="RoleTargetFramework" />
    </MSBuild>
    <Message Text="WorkerTargetFramework = $(RoleTargetFramework)" />
    
    <!-- ===============================
         Get all the CopyToOutput items from the role 
         =============================== -->
    <MSBuild
      Projects="@(WorkerRoleReference)"
      Targets="
        GetCopyToOutputDirectoryItems"
      Properties="Configuration=%(Configuration); Platform=%(Platform)"
      ContinueOnError="false"
      >
      <Output TaskParameter="TargetOutputs" ItemName="CopyToOutputItems" />
    </MSBuild>

    <Message Text="CopyToOutputItems=%(CopyToOutputItems.Identity) -> %(TargetPath)" />

    <ItemGroup>
      <WorkerFiles Include="$(WorkerTargetDir)%(TargetPath)" Condition=" '@(CopyToOutputItems)' != '' ">
        <TargetPath>%(TargetPath)</TargetPath>
      </WorkerFiles>
    </ItemGroup>

    <Message Text="WorkerFiles=%(WorkerFiles.Identity) -> %(TargetPath)" />

    <!-- ===============================
         At this point the WorkerFiles list is ready, just publish the Worker
         =============================== -->

    <!-- Make sure the intermediate worker ouput folder is created -->
    <MakeDir Directories="$(IntermediateWorkerOutputPath)" />

    <!-- Remove the files located under the intermediate output folder that are orphaned.
         In other words, remove those files that are not part of the worker project anymore.
         For example, the user renamed a file from test1.dll to test2.dll.
    -->
    <ItemGroup>
      <OrphanedWorkerFiles Include="$(IntermediateWorkerOutputPath)**\*.*" Exclude="@(WorkerFiles->'$(IntermediateWorkerOutputPath)%(TargetPath)')" />
    </ItemGroup>
    <Delete Files="@(OrphanedWorkerFiles)" ContinueOnError="true" />

    <!-- Publish the worker to the intermediate folder -->
    <Copy
      Condition=" '@(WorkerFiles)' != '' "
      SourceFiles="@(WorkerFiles)"
      DestinationFiles="@(WorkerFiles->'$(IntermediateWorkerOutputPath)%(TargetPath)')"
      SkipUnchangedFiles="true" />

    <!-- Add OutputDir and EntryPoint metadata to the WorkerRoleReference item group -->
    <ItemGroup>
      <WorkerRoleReference>
        <OutputDir>$(IntermediateWorkerOutputPath)</OutputDir>
        <EntryPoint>$(WorkerEntryPoint)</EntryPoint>
        <RoleTargetFramework>$(RoleTargetFramework)</RoleTargetFramework>
      </WorkerRoleReference>
    </ItemGroup>

    <Message Text="WorkerRoleReference=@(WorkerRoleReference) %(RoleType), %(RoleName), %(ProjectName), %(Platform), %(OutputDir), %(EntryPoint)" />

  </Target>

  <!-- =============== ValidateComputeProject ===================================== 
       Runs validations on the compute project to verify it's valid
       ============================================================================ -->
  <PropertyGroup>
    <ValidateComputeProjectDependsOn>
      ValidateRoleProjects;
      ValidateServiceFiles;
    </ValidateComputeProjectDependsOn>
  </PropertyGroup>
  <Target 
      Name="ValidateComputeProject"
      DependsOnTargets="$(ValidateComputeProjectDependsOn)">
  </Target>

  <!-- =============== ValidateRoleProjects ======================================= 
       Validates that we have the right number of role projects to match the 
       declared application architecture. Generates errors if these are not correct
       ============================================================================ -->
  <Target 
      Name="ValidateRoleProjects">

    <CreateItem Include="@(ProjectReference)" Condition=" '%(RoleType)' == 'Web' " >
      <Output TaskParameter="Include" ItemName="WebRoles" />
    </CreateItem>

    <CreateItem Include="@(ProjectReference)" Condition=" '%(RoleType)' == 'Worker' " >
      <Output TaskParameter="Include" ItemName="WorkerRoles" />
    </CreateItem>

    <Message Text="Web Project        is @(WebRoles)" />
    <Message Text="Worker Project     is @(WorkerRoles)" />

    <!-- Error out if unknown architecture or we don't have enough role projects for the architecture type -->
    <WATMessage Condition=" '@(WebRoles)'=='' And '@(WorkerRoles)'=='' " Type="Error" Code="WAT001" HelpKeyword="MissingWebOrWorkerRole"/>

  </Target>


  <!-- =============== ValidateServiceFiles ========================================= 
       Validates the integrity of both the definition file and the configuration files.       
       ============================================================================== -->
  <Target 
      Name="ValidateServiceFiles">

    <ValidateServiceFiles
        ServiceDefinitionFile="@(ServiceDefinition)"
        ServiceConfigurationFile="@(ServiceConfiguration)">
    </ValidateServiceFiles>

  </Target>


  <!-- =============== CreateManifestResourceNames ================================ 
       The IDE is calling into this target. We don't have any resource files. 
       So, implement this target to do nothing
       ============================================================================ -->

  <Target Name="CreateManifestResourceNames" />

  <!-- =============== CorePublish ================================================
       Builds the project(s) but in single-file-package mode (i.e., does not specify
       the /copyonly parameter to cspack) and copies the generated output to the 
       publish folder.
       ============================================================================ -->

  <!-- Overriding the PublishDependsOn list from common targets. -->
  <PropertyGroup>
    <PublishDependsOn>
      BeforePublish;
      CorePublish;
      AfterPublish
    </PublishDependsOn>
  </PropertyGroup>

  <Target 
      Name="CorePublish"
      DependsOnTargets="Build">

    <Message Text="Publishing starting..." />

    <Message Text="RolePlugins       is @(RoleProperties->'%(RolePlugins)')" />
    
    <Message Text="Publishing to '$(OutDir)Publish'" />

    <MakeDir Directories=" $(OutDir)Publish " />

    <PropertyGroup>
      <ServiceDefinitionFile Condition="'$(EnableIntelliTrace)'=='true'">@(ServiceDefinitionWithIntelliTrace)</ServiceDefinitionFile>
      <ServiceDefinitionFile Condition="'$(EnableIntelliTrace)'!='true'">@(ServiceDefinition)</ServiceDefinitionFile>
    </PropertyGroup>

    <Message Text="ServiceDefinitionFile is $(ServiceDefinitionFile)" />

    <CSPack
      ServiceDefinitionFile="$(ServiceDefinitionFile)"
      Output="$(OutDir)Publish\$(ProjectName).cspkg"
      PackRoles="@(Roles)"
      RoleProperties="@(RoleProperties)"
      CopyOnly="false"
      >
    </CSPack>

    <!-- Copy service configuration to output directory -->
    <Message Text="Copying the service configuration file." />

    <Copy SourceFiles="@(ServiceConfiguration)" DestinationFolder="$(OutDir)Publish" />

    <AddIntelliTraceToServiceConfiguration
      ServiceConfigurationFile="$(OutDir)Publish\@(ServiceConfiguration)"
      IntelliTraceConnectionString="$(IntelliTraceConnectionString)"
      Condition="$(EnableIntelliTrace)=='true'" />

    <Message Text="Publishing process has completed."/>

  </Target>

  <!-- =========================================================== 
       Override CoreCleanDependsOn property from Microsoft.Common.targets
       to allow us to Delete the current deployment
       =========================================================== -->

  <PropertyGroup>
    <CoreCleanDependsOn>
      DeleteCurrentDeployment;
      $(CoreCleanDependsOn)
    </CoreCleanDependsOn>
  </PropertyGroup>

  <!-- =============== IntelliTrace ================================================= 
       IntelliTrace properties & target
       ============================================================================== -->

  <PropertyGroup>
    <VisualStudioProductPath Condition=" '$(VisualStudioProductPath)' == '' ">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\10.0\Setup\VS@ProductDir)</VisualStudioProductPath>
    <VisualStudioIDEPath Condition=" '$(VisualStudioIDEPath)' == '' ">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\10.0@InstallDir)</VisualStudioIDEPath>
    <VSDataCollectorsPath Condition=" '$(VSDataCollectorsPath)' == '' ">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\10.0\TraceDebugger@VSTraceCollector)</VSDataCollectorsPath>
    <VSReferencedAssembliesPath Condition=" '$(VSReferencedAssembliesPath)' == '' ">$(VisualStudioIDEPath)ReferenceAssemblies\v2.0\</VSReferencedAssembliesPath>
    <VSPrivateAssembliesPath Condition=" '$(VSPrivateAssembliesPath)' == '' ">$(VisualStudioIDEPath)PrivateAssemblies\</VSPrivateAssembliesPath>
    <VSPublicAssembliesPath Condition=" '$(VSPublicAssembliesPath)' == '' ">$(VisualStudioIDEPath)PublicAssemblies\</VSPublicAssembliesPath>
    <CloudToolsInstallPath Condition=" '$(CloudToolsInstallPath)' == '' ">$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows Azure Tools for Microsoft Visual Studio 2010\1.0@InstallPath)</CloudToolsInstallPath>

    <!-- In order to enable testing without tools installed, fallback to default path if InstallPath is not set in the Registry. 
         The files are copied there by CctPackage project build. $(ProgramFiles) is set to Program Files (x86) by MSBuild. -->
    <DefaultCloudToolsPath Condition=" '$(DefaultCloudToolsPath)' == '' ">$(ProgramFiles)\Windows Azure Tools\1.2\Visual Studio 10.0\</DefaultCloudToolsPath>
    <CloudToolsInstallPath Condition=" '$(CloudToolsInstallPath)' == '' ">$(DefaultCloudToolsPath)</CloudToolsInstallPath>
    <CloudToolsIntelliTracePath Condition=" '$(CloudToolsIntelliTracePath)' == '' ">$(CloudToolsInstallPath)IntelliTrace\</CloudToolsIntelliTracePath>

    <IntelliTraceTargetDir>$(BaseIntermediateOutputPath)\$(Configuration)\IntelliTrace</IntelliTraceTargetDir>
    <IntelliTraceRuntimeDir>$(IntelliTraceTargetDir)\Runtime</IntelliTraceRuntimeDir>
    <IntelliTraceLoggerDir>$(IntelliTraceRuntimeDir)\64</IntelliTraceLoggerDir>
    <IntelliTraceAddonManifestPath>$(CloudToolsIntelliTracePath)\IntelliTrace.csplugin</IntelliTraceAddonManifestPath>
    <UserIntelliTraceCollectionPlanPath>$(AppData)\Microsoft\VisualStudio\10.0\Cloud Tools\collectionplan.xml</UserIntelliTraceCollectionPlanPath>
    <DefaultIntelliTraceCollectionPlanPath>$(CloudToolsIntelliTracePath)\collectionplan.xml</DefaultIntelliTraceCollectionPlanPath>
    <IntelliTraceCollectionPlanPath Condition="Exists('$(UserIntelliTraceCollectionPlanPath)')">$(UserIntelliTraceCollectionPlanPath)</IntelliTraceCollectionPlanPath>
    <IntelliTraceCollectionPlanPath Condition=" '$(IntelliTraceCollectionPlanPath)' == '' ">$(DefaultIntelliTraceCollectionPlanPath)</IntelliTraceCollectionPlanPath>
  </PropertyGroup>

  <ItemGroup>
    <IntelliTraceFiles
      Include= "$(CloudToolsIntelliTracePath)\Microsoft.Cct.IntelliTrace.Common.dll;
                $(CloudToolsIntelliTracePath)\Microsoft.Cct.IntelliTrace.Agent.dll;
                $(CloudToolsIntelliTracePath)\IntelliTraceAgentHost.exe;
                $(CloudToolsIntelliTracePath)\IntelliTraceAgentHost.exe.config;
                $(CloudToolsIntelliTracePath)\IntelliTraceStartupTask.exe;
                $(CloudToolsIntelliTracePath)\IntelliTraceStartupTask.exe.config;
                $(IntelliTraceAddonManifestPath);
                $(ServiceHostingSDKInstallDir)\ref\Microsoft.WindowsAzure.StorageClient.dll;
                "/>

    <IntelliTraceRuntimeFiles
      Include= "$(VSDataCollectorsPath)\IntelliTrace.exe;
                $(VSDataCollectorsPath)\IntelliTrace.exe.config;
                $(VSDataCollectorsPath)\Microsoft.VisualStudio.DefaultDataQueries.dll;
                $(VSDataCollectorsPath)\Microsoft.VisualStudio.Enterprise.AspNetHelper.dll;
                $(VSDataCollectorsPath)\Microsoft.VisualStudio.TraceCollector.dll;
                $(VSDataCollectorsPath)\Microsoft.VisualStudio.TraceCollector.dll.config;
                $(VSDataCollectorsPath)\Microsoft.VisualStudio.VIL.NotifyPointInProcHost.dll;
                $(VSPublicAssembliesPath)\Microsoft.VisualStudio.IntelliTrace.dll;
                $(VSReferencedAssembliesPath)\Microsoft.VisualStudio.QualityTools.Common.dll;
                $(VSReferencedAssembliesPath)\Microsoft.VisualStudio.QualityTools.ExecutionCommon.dll;
                $(VSPrivateAssembliesPath)\Microsoft.VisualStudio.VIL.Host.dll;
                $(SYSTEMROOT)\assembly\GAC_MSIL\Microsoft.VisualStudio.QualityTools.Resource\10.0.0.0__b03f5f7f11d50a3a\Microsoft.VisualStudio.QualityTools.Resource.dll;
                $(SYSTEMROOT)\assembly\GAC_MSIL\Microsoft.VisualStudio.VIL\10.0.0.0__b03f5f7f11d50a3a\Microsoft.VisualStudio.VIL.dll;
                "/>

    <VSTraceProfiler64Path
      Condition=" '@(VSTraceProfiler64Path)' == '' and ('$(PROCESSOR_ARCHITECTURE)' == 'AMD64' or $(PROCESSOR_ARCHITEW6432) == 'AMD64' ) "
      Include="$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{301EC75B-AD5A-459C-A4C4-911C878FA196}\InprocServer32', '', '', RegistryView.Registry64))" />

    <!-- On 32 bit machines the TraceLogProfiler is installed to different location and has different file name. It is not being registered. -->
    <VSTraceProfiler64Path
      Condition=" '@(VSTraceProfiler64Path)' == '' "
      Include="$(VisualStudioProductPath)Team Tools\TraceDebugger Tools\TraceLogProfiler.dll" />

    <VSTraceProfiler32Path
      Condition=" '@(VSTraceProfiler32Path)' == '' "
      Include="$(Registry:HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\{301EC75B-AD5A-459C-A4C4-911C878FA196}\InprocServer32@)" />

  </ItemGroup>

  <ItemGroup>
    <ServiceDefinitionWithIntelliTrace Include="@(ServiceDefinition->'%(RecursiveDirectory)%(Filename).itrace%(Extension)')" />
  </ItemGroup>

  <!-- Prepares files needed for IntelliTrace Support -->
  <Target Name="IntelliTrace" Condition="'$(EnableIntelliTrace)'=='true'">

    <Message Text="EnableIntelliTrace is $(EnableIntelliTrace)" />
    <Message Text="IntelliTraceFiles is @(IntelliTraceFiles)" />
    <Message Text="IntelliTraceRuntimeFiles is @(IntelliTraceRuntimeFiles)" />
    <Message Text="IntelliTraceTargetDir is $(IntelliTraceTargetDir)" />
    <Message Text="IntelliTraceRuntimeDir is $(IntelliTraceRuntimeDir)" />
    <Message Text="IntelliTraceCollectionPlanPath is $(IntelliTraceCollectionPlanPath)" />
    <Message Text="VSTraceProfiler64Path is @(VSTraceProfiler64Path)" />
    <Message Text="VSTraceProfiler32Path is @(VSTraceProfiler32Path)" />
    <Message Text="PROCESSOR_ARCHITECTURE is $(PROCESSOR_ARCHITECTURE)" />
    <Message Text="PROCESSOR_ARCHITEW6432 is $(PROCESSOR_ARCHITEW6432)" />

    <WATMessage Condition="'@(VSTraceProfiler64Path)' == '' or !Exists('@(VSTraceProfiler64Path)')" Type="Error" Code="WAT090" />

    <Message Text="Adding IntelliTrace components..." />

    <MakeDir Directories="$(IntelliTraceTargetDir);$(IntelliTraceRuntimeDir);$(IntelliTraceLoggerDir)" />

    <!-- Copy the Cloud Tools IntelliTrace support files (agent, startup task, etc) -->
    <Copy
      SourceFiles="@(IntelliTraceFiles)"
      DestinationFolder="$(IntelliTraceTargetDir)" 
      SkipUnchangedFiles="true" 
      OverwriteReadOnlyFiles="true" >
      <Output TaskParameter="CopiedFiles" ItemName="FileWrites" />
    </Copy>

    <!-- Copy the IntelliTrace runtime files -->
    <Copy
      SourceFiles="@(IntelliTraceRuntimeFiles)"
      DestinationFolder="$(IntelliTraceRuntimeDir)" 
      SkipUnchangedFiles="true" 
      OverwriteReadOnlyFiles="true" >
      <Output TaskParameter="CopiedFiles" ItemName="FileWrites" />
    </Copy>

    <!-- Copy the IntelliTrace runtime files to the logger directory. Workaround to enable xcopy deployable IntelliTrace. (see explanation below)  -->
    <Copy
      SourceFiles="@(IntelliTraceRuntimeFiles)"
      DestinationFolder="$(IntelliTraceLoggerDir)"       
      SkipUnchangedFiles="true" 
      OverwriteReadOnlyFiles="true" >
      <Output TaskParameter="CopiedFiles" ItemName="FileWrites" />
    </Copy>

    <!-- Copy the 32 bit TraceLogProfiler.dll.
         The logger (IntelliTrace.exe) is a 32bit process, and it requires 32bit TraceLogProfiler in the same directory. 
         Azure host processes, however, 64 bit and use 64 bit version of TraceLogProfiler. Therefore, we need a separate directory for the logger. -->
    <Copy
      SourceFiles="@(VSTraceProfiler32Path)"
      DestinationFolder="$(IntelliTraceLoggerDir)"       
      SkipUnchangedFiles="true" 
      OverwriteReadOnlyFiles="true" >
      <Output TaskParameter="CopiedFiles" ItemName="FileWrites" />      
    </Copy>

    <!-- Copy the 64 bit TraceLogProfiler.dll and rename it to 64TraceLogProfiler.dll. 
         This is a workaround to enable xcopy-deployable IntelliTrace. 
         At runtime the TraceLogProfiler discovers the path to the logger using COR_PROFILER_PATH environment variable, and assumes it ends with "TraceLogProfiler.dll".
         It treats everything before "TraceLogProfiler.dll" as a directory name.Therefore when the profiler executable is named "64TraceLogProfiler.dll", 
         the calculated logger path would be "64" (This needs to match IntelliTraceLoggerDir property).
    -->
    <Copy
      SourceFiles="@(VSTraceProfiler64Path)"
      DestinationFiles="$(IntelliTraceRuntimeDir)\64TraceLogProfiler.dll" 
      SkipUnchangedFiles="true" 
      OverwriteReadOnlyFiles="true" >
      <Output TaskParameter="CopiedFiles" ItemName="FileWrites" />
    </Copy>

    <!-- Copy the IntelliTrace collection plan file.  -->
    <Copy
      SourceFiles="$(IntelliTraceCollectionPlanPath)"
      DestinationFolder="$(IntelliTraceRuntimeDir)"       
      SkipUnchangedFiles="true" 
      OverwriteReadOnlyFiles="true" >
      <Output TaskParameter="CopiedFiles" ItemName="FileWrites" />
    </Copy>

    <!-- Create a copy of .csdef file since we need to add IntelliTrace related settings.  -->
    <Copy
      SourceFiles="@(ServiceDefinition)"
      DestinationFiles="@(ServiceDefinitionWithIntelliTrace)"       
      OverwriteReadOnlyFiles="true" >
      <Output TaskParameter="CopiedFiles" ItemName="FileWrites" />
    </Copy>

    <!-- Add IntelliTrace related settings to .csdef file  -->
    <AddIntelliTraceToServiceDefinition
      ServiceDefinitionFile="@(ServiceDefinitionWithIntelliTrace)" />

  </Target>
  <!-- End IntelliTrace Support -->
  
</Project>
